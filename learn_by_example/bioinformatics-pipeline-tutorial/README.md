## README

These scripts were written for a [blog
post](https://ricomnl.com/blog/bottom-up-bioinformatics-pipeline/)
demonstrating how a bioinformatics pipeline can be implemented. I go through
these scripts in an attempt to learn more about Python scripting.

### 01 digest protein

This is the first script of the pipeline and as the name suggests, it digests a
protein. The protein sequence is stored in a single entry FASTA file and an
enzyme regex should be provided to tell the script how it should be digested.

The full usage can be obtained by typing `./01_digest_protein.py -h`. This
usage is generated by using the
[argparse](https://docs.python.org/3/library/argparse.html) module and I have
written [some
notes](https://davetang.github.io/bioinformatics_tips/get_option.html#Python)
on using this module.

```bash
usage: 01_digest_protein.py [-h] [--enzyme_regex ENZYME_REGEX]
                            [--missed_cleavages MISSED_CLEAVAGES]
                            [--min_length MIN_LENGTH]
                            [--max_length MAX_LENGTH]
                            input_file output_file

positional arguments:
  input_file            A .fasta file containing a protein.
  output_file           A .txt output file to write the peptides to.

optional arguments:
  -h, --help            show this help message and exit
  --enzyme_regex ENZYME_REGEX
                        A regex for the enzyme to use for the digest. E.g.
                        [KR] for trypsin.
  --missed_cleavages MISSED_CLEAVAGES
                        Number of missed cleavages for the digest.
  --min_length MIN_LENGTH
                        Minimum length for a peptide to be considered valid.
  --max_length MAX_LENGTH
                        Maximum length for a peptide to be considered valid.
```

The input to the script is a single entry FASTA file. Below is the amino acid
sequence for [MYC](https://www.genecards.org/cgi-bin/carddisp.pl?gene=MYC)
stored in `MYC.fasta`.

```
>sp|P01106|MYC_HUMAN Myc proto-oncogene protein OS=Homo sapiens OX=9606 GN=MYC PE=1 SV=1
MPLNVSFTNRNYDLDYDSVQPYFYCDEEENFYQQQQQSELQPPAPSEDIWKKFELLPTPP
LSPSRRSGLCSPSYVAVTPFSLRGDNDGGGGSFSTADQLEMVTELLGGDMVNQSFICDPD
DETFIKNIIIQDCMWSGFSAAAKLVSEKLASYQAARKDSGSPNPARGHSVCSTSSLYLQD
LSAAASECIDPSVVFPYPLNDSSSPKSCASQDSSAFSPSSDSLLSSTESSPQGSPEPLVL
HEETPPTTSSDSEEEQEDEEEIDVVSVEKRQAPGKRSESGSPSAGGHSKPPHSPLVLKRC
HVSTHQHNYAAPPSTRKDYPAAKRVKLDSVRVLRQISNNRKCTSPRSSDTEENVKRRTHN
VLERQRRNELKRSFFALRDQIPELENNEKAPKVVILKKATAYILSVQAEEQKLISEEDLL
RKRREQLKHKLEQLRNSCA
```

The script is organised into four functions:

1. `load_fasta`
2. `save_peptides`
3. `digest_protein`
4. `main`

#### Load FASTA

The FASTA file opened using `with open(filename, "r") as fasta_file:` and is
considered [good
practice](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files)
when dealing with file objects. The entire file is read into `lines` as a long
string and then
[splitlines](https://docs.python.org/3/library/stdtypes.html#str.splitlines) is
used to split the string at line boundaries into a list. The first list entry
is assumed to be FASTA header and every other line afterwards contains the
amino acid sequence and is joined.

#### Save peptides

The list of peptides is written to an output file using `with open(filename,
"w") as output_file:` and by iterating through the list of peptides. The
`write` method is used with
[format](https://docs.python.org/3/library/stdtypes.html#str.format) to save
each peptide into `output_file`. Note that newlines need to be specified with
`write` unlike `print`.

#### Digest protein

The protein sequence is split according to an input regular expression
(abbreviated as regex). The default regex is `[KR]` which defines a _character
class_, which are sets of characters that can match at a single location. This
character class is composed of two amino acids: lysine (K) and arginine (R).
The code `enzyme_regex.finditer(protein_sequence)` finds all amino acids that
are either K or R. The first few matches, start and end index (0 indexed), for
`MYC.fasta` are shown below.

```
9 10
50 51
51 52
64 65
65 66
82 83
125 126
```

The `9 10` indicates that at position 9 until 10, there is a match. We can
confirm this by examining the start of `MYC.fasta`.

```
012345678 9 0123456789
MPLNVSFTN R NYDLDYDSVQ
```

A `sites` list is created to store the matching end index. The `sites` list
starts with a zero index because a single cut downstream of the start of the
sequence can generate a short peptide. Similarily, the `sites` list ends with
the length of the protein sequence because a cut upstream of the end can
generate a peptide.

The function accepts an argument called `missed_cleavages` (default = 0) and
this is used to generate peptide sequences by "skipping" (because a cleavage
was missed) cuts. To illustrate, a missed cleavage of 1 will generate three
peptides for sequence `NNNNNRYYYYYR`:

1. NNNNNR
2. NNNNNRYYYYYR (additional peptide generated due to missed cleavage)
3. YYYYYR

The first five predicted peptides for `MYC.fasta` with a missed cleavage of 0
(default), minimum length of 4 (default), and maximum length of 75 (default)
are shown below.

```
MPLNVSFTNR
NYDLDYDSVQPYFYCDEEENFYQQQQQSELQPPAPSEDIWK
FELLPTPPLSPSR
SGLCSPSYVAVTPFSLR
GDNDGGGGSFSTADQLEMVTELLGGDMVNQSFICDPDDETFIK
```

We can manually check the results by examining the FASTA sequence. The `|`
indicates the match end index, which is used to define the start of the
sequence; thus the start of the peptide sequence does not include the matching
amino acid. The end of the peptide sequence is defined by the next matching end
index.

```
0123456789 | 01234567890123456789012345678901234567890 | 123456789
MPLNVSFTNR | NYDLDYDSVQPYFYCDEEENFYQQQQQSELQPPAPSEDIWK | KFELLPTPP
```

Recall that string slicing does not include the end index. But since the end of
the string slicing index used to generate the peptides is the matching end
index, the matching amino is included as the last peptide.

```python
s = '0123456789'
s[1:5] # returns '1234'
```

#### Main

A main function is used as an [entry
  point](https://en.wikipedia.org/wiki/Entry_point#C_and_C++) and calls the
other three functions.

### 02 count amino acids

The `02_count_amino_acids.py` script takes the peptide list generated by
`01_digest_protein.py` and produces a counts file.

```bash
usage: 02_count_amino_acids.py [-h] [--amino_acid AMINO_ACID]
                               input_fasta input_peptides output_file

positional arguments:
  input_fasta           A .fasta file containing a protein.
  input_peptides        A .txt file containing peptides.
  output_file           A .tsv output file to write the counts to.

optional arguments:
  -h, --help            show this help message and exit
  --amino_acid AMINO_ACID
                        The one letter code for the amino acid to target.
                        Defaults to C for cysteine.
```

The script is organised into the following functions:

1. `load_fasta`
2. `load_peptides`
3. `save_counts`
4. `num_peptides`
5. `num_peptides_with_aa`
6. `total_num_aa_in_protein`
7. `num_aa_in_protein`
8. `main`

The functions are executed in the following order in the `main` function.

1. `_, protein_sequence = load_fasta(input_fasta)`

The function `load_fasta` returns the FASTA header and the sequence but since
the header info is not used anywhere, it is assigned to `_`, which serves as a
[throwaway variable
name](https://stackoverflow.com/questions/5893163/what-is-the-purpose-of-the-single-underscore-variable-in-python).

2. `peptides = load_peptides(input_peptides)`

Peptides are loaded into the `peptides` list.

3. `n_peptides = num_peptides(peptides)`

The number of peptides are counted by returning the length of the `peptides` list.

4. `n_peptides_with_aa = num_peptides_with_aa(peptides, **kwargs)`

The `num_peptides_with_aa` function uses (_what I think is_) a list
comprehension to count the number of a certain amino acid in the peptide
sequences. The specific code is:

`sum([1 if amino_acid in peptide else 0 for peptide in peptides])`

If a peptide sequence contains 1 or more of a certain amino acid, then 1 will
be stored in a new list, otherwise 0 will be stored.

5. `total_aa_in_protein = total_num_aa_in_protein(protein_sequence)`

The number of amino acids in the protein sequence is counted by returning the
length of `protein_sequence`.

6. `aa_in_protein = num_aa_in_protein(protein_sequence, **kwargs)`

The `count` method is used to count the number of a certain amino acid in
`protein_sequence`.

Finally the `save_counts` function is called:

```python
save_counts(
    output_file,
    [amino_acid, n_peptides, n_peptides_with_aa, total_aa_in_protein, aa_in_protein]
)
```

The `save_counts` function can print a list of any length. It achieves this by
using the `join` method, which only works on strings and because of this `str`
is used to convert the list items into strings. The code for the function is
below.

```python
def save_counts(filename, peptide_counts):
	"""
	Write out the peptide counts to a .tsv file using tabs as a separator.
	"""
	with open(filename, "w") as output_file:
		output_file.write("{}\n".format("\t".join([str(c) for c in peptide_counts])))
```

The final output for MYC is a tab-delimited file that shows the tallied amino
acid, the number of peptides, the number of peptides with 1 or more of the
amino acid, the length of the full protein sequence, and the number of amino
acids in the full protein sequence.

```
C	30	9	439	10
```

### 03a plot count

The `03a_plot_count.py` script plots the count output from
`02_count_amino_acids.py` using [matplotlib](https://matplotlib.org/).

```bash
usage: 03a_plot_count.py [-h] input_file output_file

positional arguments:
  input_file   A .tsv file containing the peptide counts.
  output_file  A .png output file to write the plot to. Use `show` to just
               show the output.

optional arguments:
  -h, --help   show this help message and exit
```

The script has three functions:

1. `load_counts`
2. `plot_counts`
3. `main`

The `load_counts` function splits the lines in the input file using
`splitlines` and then performs another split using tabs on each line split. The
`0` index is used because there should only be one line in the count file and
that corresponds to the counts.

`counts = [line.split('\t') for line in count_file.read().splitlines()][0]`

The `plot_counts` function uses matplotlib to produce the count plots. The
`subplot()` function creates two sub plots (on a single row). Bar plots are
produced using the `bar()` function, which takes `x` and `y` values. The other
matplotlib functions add labels and other aesthetics. Note that this function
does not have a `return` statement but the plot can still be accessed, somehow.

The `main` function calls the other two functions to show or produce a plot.

### 03b get report

The `03b_get_report.py` script is meant for concatenating a list of count
output files into a single text file (for convenience). Since the number of
input files is variable, the author of this script made the argument for output
file an optional one.

```
usage: 03b_get_report.py [-h] [--output_file OUTPUT_FILE]
                         input_files [input_files ...]

positional arguments:
  input_files           A list of .tsv files containing the peptide counts.

optional arguments:
  -h, --help            show this help message and exit
  --output_file OUTPUT_FILE
                        A .tsv output file to write the report to.
```

However, an output file name is a necessary input (not an optional one) since
the script will exit if an output file is not provided.

```
Traceback (most recent call last):
  File "./03b_get_report.py", line 63, in <module>
    output_file = kwargs.pop("output_file")
KeyError: 'output_file'
```

Therefore the script should make the first positional argument the name of the
output file and then all other arguments are input count file.

The script is organised into four functions:

1. `load_counts`
2. `save_report`
3. `get_report`
4. `main`

The `load_counts`, `save_report`, and `main` functions are the same as
previously described functions. The `get_report` function collates all the
counts into a single list named `count_list`.

The `count_list` is a 2D list and is initiated with the column header.

```python
count_list = [[
    "Protein",
    "Target Amino Acid",
    "No. of Peptides", 
    "No. of Peptides w/ Target Amino Acid", 
    "Total No. of Amino Acids", 
    "No. of Target Amino Acid"
]]
```

Each count file is loaded using `load_counts` and the `count_list` is appended
with the _file name_ and the counts. The intention of the code is to parse the
file name to obtain the protein name but since I named the count file with a
different naming convention, the protein name contains other characters.

```
Protein	Target Amino Acid	No. of Peptides	No. of Peptides w/ Target Amino Acid	Total No. of Amino Acids	No. of Target Amino Acid
MYC_count	C	30	9	439	10
```

